{"version":3,"file":"component---src-pages-clues-js-691a944d97100261298f.js","mappings":"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","sources":["webpack://learn-cryptic/./src/assets/img/difficulty/1.svg","webpack://learn-cryptic/./src/pages/Clues.js","webpack://learn-cryptic/./src/assets/img/difficulty/2.svg","webpack://learn-cryptic/./src/assets/img/difficulty/3.svg","webpack://learn-cryptic/./src/assets/img/difficulty/4.svg","webpack://learn-cryptic/./node_modules/react-router/node_modules/cookie/dist/index.js"],"sourcesContent":["export default \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjUwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDwhLS0gRmlyc3QgQ2lyY2xlIC0tPgogIDxjaXJjbGUgY3g9IjI1IiBjeT0iMjUiIHI9IjIwIiBmaWxsPSIjYjBkMjM2IiAvPgogIDwhLS0gU2Vjb25kIENpcmNsZSAtLT4KICA8Y2lyY2xlIGN4PSI3NSIgY3k9IjI1IiByPSIyMCIgZmlsbD0iI0UyRTJFMiIgLz4KICA8IS0tIFRoaXJkIENpcmNsZSAtLT4KICA8Y2lyY2xlIGN4PSIxMjUiIGN5PSIyNSIgcj0iMjAiIGZpbGw9IiNFMkUyRTIiIC8+CiAgPCEtLSBGb3VydGggQ2lyY2xlIC0tPgogIDxjaXJjbGUgY3g9IjE3NSIgY3k9IjI1IiByPSIyMCIgZmlsbD0iI0UyRTJFMiIgLz4KPC9zdmc+Cg==\"","import React, { useRef, createRef } from 'react'\nimport { Link } from \"react-router-dom\";\n\nimport d1 from '../assets/img/difficulty/1.svg';\nimport d2 from '../assets/img/difficulty/2.svg';\nimport d3 from '../assets/img/difficulty/3.svg';\nimport d4 from '../assets/img/difficulty/4.svg';\n\nconst Clues = ({ cluesData, completedClues }) => {\n\n\n\tlet tilesRef = useRef(cluesData.map(() => createRef()))\n\n\t// only past clues\n\tlet archiveTiles = cluesData.filter(clue => {\n\n\t\tfunction isTodayOrBefore(date1Str) {\n\n\t\t\tconst date1 = new Date(date1Str);\n    \t\tconst date2 = new Date();\n\n\t\t\t// Strip time part by setting hours, minutes, seconds, and milliseconds to zero\n\t\t\tconst d1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());\n\t\t\tconst d2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());\n\t\t\n\t\t\t// Compare the two dates\n\t\t\tif (d1.getTime() === d2.getTime()) {\n\t\t\t\treturn true; // Same day\n\t\t\t} else if (d1.getTime() < d2.getTime()) {\n\t\t\t\treturn true; // date1 is before date2\n\t\t\t} else {\n\t\t\t\treturn false; // date1 is after date2\n\t\t\t}\n\t\t}\n\n\t\treturn isTodayOrBefore(clue.release)\n\t})\n\n\tarchiveTiles = archiveTiles.map((clue, index) => {\n\n\t\tconst getRelease = (release) => new Date(release)\n\n\t\tconst getImg = (difficulty) => {\n\t\t\tswitch (Number(difficulty)) {\n\t\t\t\tcase 1:\n\t\t\t\t  return d1\n\t\t\t\tcase 2:\n\t\t\t\t\treturn d2\n\t\t\t\tcase 3:\n\t\t\t\t\treturn d3\n\t\t\t\tcase 4:\n\t\t\t\t\treturn d4\n\t\t\t\tdefault:\n\t\t\t\t\treturn d1\n\t\t\t  }\n\t\t}\n\n\t\tconst completedClue = completedClues.find(c => c.id == clue.id)\n\n\t\tconst stats = completedClue && <>\n\t\t\t<div className=\"tile-stats\">\n\t\t\t\t<span className='stat-hints'><span className=\"stat\">{completedClue.hints}</span>&nbsp;h</span>\n\t\t\t\t<span className='stat-guesses'><span className=\"stat\">{completedClue.guesses}</span>&nbsp;g</span>\n\t\t\t</div>\n\t\t</>\n\n\t\treturn (\n\t\t<Link to={`/clues/${clue.id}`} className={`archive-clue${!!completedClue ? ' completed' : ''} ${completedClue && completedClue.how}`} key={clue.id}>\n\t\t\t<div className='archive-release'>\n\t\t\t\t<span>\n\t\t\t\t\t<span>{getRelease(clue.release).toLocaleString('en-us', { month: 'short' })}</span>&nbsp;\n\t\t\t\t\t<span>{getRelease(clue.release).getDate()}</span>\n\t\t\t\t</span>\n\t\t\t\t<br></br>\n\t\t\t\t<span>{getRelease(clue.release).getFullYear()}</span>\n\t\t\t</div>\n\t\t\t<div id={clue.id} className='archive-tile' ref={tilesRef.current[index]} >\n\t\t\t\t<div className='tile-img-stats'>\n\t\t\t\t\t{stats}\n\t\t\t\t\t<img className='tile-difficulty' src={getImg(clue.difficulty)} title={clue.difficulty} aria-label='difficulty' />\n\t\t\t\t</div>\n\t\t\t\t<span className='tile-name'>{clue.clue.value}</span>\n\t\t\t\t{/* <span className='tile-source'>{clue.source.value}</span> */}\n\t\t\t</div>\n\t\t</Link>\n\t\t)\n\t})\n\n\treturn(\n\t\t<div className='archive container'>\n\t\t\t{archiveTiles}\n\t\t</div>\n\t)\n}\n\nexport default Clues;","export default \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjUwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDwhLS0gRmlyc3QgQ2lyY2xlIC0tPgogIDxjaXJjbGUgY3g9IjI1IiBjeT0iMjUiIHI9IjIwIiBmaWxsPSIjZmZkYzdhIiAvPgogIDwhLS0gU2Vjb25kIENpcmNsZSAtLT4KICA8Y2lyY2xlIGN4PSI3NSIgY3k9IjI1IiByPSIyMCIgZmlsbD0iI2ZmZGM3YSIgLz4KICA8IS0tIFRoaXJkIENpcmNsZSAtLT4KICA8Y2lyY2xlIGN4PSIxMjUiIGN5PSIyNSIgcj0iMjAiIGZpbGw9IiNFMkUyRTIiIC8+CiAgPCEtLSBGb3VydGggQ2lyY2xlIC0tPgogIDxjaXJjbGUgY3g9IjE3NSIgY3k9IjI1IiByPSIyMCIgZmlsbD0iI0UyRTJFMiIgLz4KPC9zdmc+Cg==\"","export default \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjUwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDwhLS0gRmlyc3QgQ2lyY2xlIC0tPgogIDxjaXJjbGUgY3g9IjI1IiBjeT0iMjUiIHI9IjIwIiBmaWxsPSIjZWI5NTYwIiAvPgogIDwhLS0gU2Vjb25kIENpcmNsZSAtLT4KICA8Y2lyY2xlIGN4PSI3NSIgY3k9IjI1IiByPSIyMCIgZmlsbD0iI2ViOTU2MCIgLz4KICA8IS0tIFRoaXJkIENpcmNsZSAtLT4KICA8Y2lyY2xlIGN4PSIxMjUiIGN5PSIyNSIgcj0iMjAiIGZpbGw9IiNlYjk1NjAiIC8+CiAgPCEtLSBGb3VydGggQ2lyY2xlIC0tPgogIDxjaXJjbGUgY3g9IjE3NSIgY3k9IjI1IiByPSIyMCIgZmlsbD0iI0UyRTJFMiIgLz4KPC9zdmc+Cg==\"","export default \"data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjUwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDwhLS0gRmlyc3QgQ2lyY2xlIC0tPgogIDxjaXJjbGUgY3g9IjI1IiBjeT0iMjUiIHI9IjIwIiBmaWxsPSIjZTM1OTUyIiAvPgogIDwhLS0gU2Vjb25kIENpcmNsZSAtLT4KICA8Y2lyY2xlIGN4PSI3NSIgY3k9IjI1IiByPSIyMCIgZmlsbD0iI2UzNTk1MiIgLz4KICA8IS0tIFRoaXJkIENpcmNsZSAtLT4KICA8Y2lyY2xlIGN4PSIxMjUiIGN5PSIyNSIgcj0iMjAiIGZpbGw9IiNlMzU5NTIiIC8+CiAgPCEtLSBGb3VydGggQ2lyY2xlIC0tPgogIDxjaXJjbGUgY3g9IjE3NSIgY3k9IjI1IiByPSIyMCIgZmlsbD0iI2UzNTk1MiIgLz4KPC9zdmc+Cg==\"","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parse = parse;\nexports.serialize = serialize;\n/**\n * RegExp to match cookie-name in RFC 6265 sec 4.1.1\n * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2\n * which has been replaced by the token definition in RFC 7230 appendix B.\n *\n * cookie-name       = token\n * token             = 1*tchar\n * tchar             = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" /\n *                     \"*\" / \"+\" / \"-\" / \".\" / \"^\" / \"_\" /\n *                     \"`\" / \"|\" / \"~\" / DIGIT / ALPHA\n *\n * Note: Allowing more characters - https://github.com/jshttp/cookie/issues/191\n * Allow same range as cookie value, except `=`, which delimits end of name.\n */\nconst cookieNameRegExp = /^[\\u0021-\\u003A\\u003C\\u003E-\\u007E]+$/;\n/**\n * RegExp to match cookie-value in RFC 6265 sec 4.1.1\n *\n * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\n * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n *                     ; US-ASCII characters excluding CTLs,\n *                     ; whitespace DQUOTE, comma, semicolon,\n *                     ; and backslash\n *\n * Allowing more characters: https://github.com/jshttp/cookie/issues/191\n * Comma, backslash, and DQUOTE are not part of the parsing algorithm.\n */\nconst cookieValueRegExp = /^[\\u0021-\\u003A\\u003C-\\u007E]*$/;\n/**\n * RegExp to match domain-value in RFC 6265 sec 4.1.1\n *\n * domain-value      = <subdomain>\n *                     ; defined in [RFC1034], Section 3.5, as\n *                     ; enhanced by [RFC1123], Section 2.1\n * <subdomain>       = <label> | <subdomain> \".\" <label>\n * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]\n *                     Labels must be 63 characters or less.\n *                     'let-dig' not 'letter' in the first char, per RFC1123\n * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>\n * <let-dig-hyp>     = <let-dig> | \"-\"\n * <let-dig>         = <letter> | <digit>\n * <letter>          = any one of the 52 alphabetic characters A through Z in\n *                     upper case and a through z in lower case\n * <digit>           = any one of the ten digits 0 through 9\n *\n * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173\n *\n * > (Note that a leading %x2E (\".\"), if present, is ignored even though that\n * character is not permitted, but a trailing %x2E (\".\"), if present, will\n * cause the user agent to ignore the attribute.)\n */\nconst domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;\n/**\n * RegExp to match path-value in RFC 6265 sec 4.1.1\n *\n * path-value        = <any CHAR except CTLs or \";\">\n * CHAR              = %x01-7F\n *                     ; defined in RFC 5234 appendix B.1\n */\nconst pathValueRegExp = /^[\\u0020-\\u003A\\u003D-\\u007E]*$/;\nconst __toString = Object.prototype.toString;\nconst NullObject = /* @__PURE__ */ (() => {\n    const C = function () { };\n    C.prototype = Object.create(null);\n    return C;\n})();\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n */\nfunction parse(str, options) {\n    const obj = new NullObject();\n    const len = str.length;\n    // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.\n    if (len < 2)\n        return obj;\n    const dec = options?.decode || decode;\n    let index = 0;\n    do {\n        const eqIdx = str.indexOf(\"=\", index);\n        if (eqIdx === -1)\n            break; // No more cookie pairs.\n        const colonIdx = str.indexOf(\";\", index);\n        const endIdx = colonIdx === -1 ? len : colonIdx;\n        if (eqIdx > endIdx) {\n            // backtrack on prior semicolon\n            index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n            continue;\n        }\n        const keyStartIdx = startIndex(str, index, eqIdx);\n        const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);\n        const key = str.slice(keyStartIdx, keyEndIdx);\n        // only assign once\n        if (obj[key] === undefined) {\n            let valStartIdx = startIndex(str, eqIdx + 1, endIdx);\n            let valEndIdx = endIndex(str, endIdx, valStartIdx);\n            const value = dec(str.slice(valStartIdx, valEndIdx));\n            obj[key] = value;\n        }\n        index = endIdx + 1;\n    } while (index < len);\n    return obj;\n}\nfunction startIndex(str, index, max) {\n    do {\n        const code = str.charCodeAt(index);\n        if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */)\n            return index;\n    } while (++index < max);\n    return max;\n}\nfunction endIndex(str, index, min) {\n    while (index > min) {\n        const code = str.charCodeAt(--index);\n        if (code !== 0x20 /*   */ && code !== 0x09 /* \\t */)\n            return index + 1;\n    }\n    return min;\n}\n/**\n * Serialize data into a cookie header.\n *\n * Serialize a name value pair into a cookie string suitable for\n * http headers. An optional options object specifies cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n */\nfunction serialize(name, val, options) {\n    const enc = options?.encode || encodeURIComponent;\n    if (!cookieNameRegExp.test(name)) {\n        throw new TypeError(`argument name is invalid: ${name}`);\n    }\n    const value = enc(val);\n    if (!cookieValueRegExp.test(value)) {\n        throw new TypeError(`argument val is invalid: ${val}`);\n    }\n    let str = name + \"=\" + value;\n    if (!options)\n        return str;\n    if (options.maxAge !== undefined) {\n        if (!Number.isInteger(options.maxAge)) {\n            throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);\n        }\n        str += \"; Max-Age=\" + options.maxAge;\n    }\n    if (options.domain) {\n        if (!domainValueRegExp.test(options.domain)) {\n            throw new TypeError(`option domain is invalid: ${options.domain}`);\n        }\n        str += \"; Domain=\" + options.domain;\n    }\n    if (options.path) {\n        if (!pathValueRegExp.test(options.path)) {\n            throw new TypeError(`option path is invalid: ${options.path}`);\n        }\n        str += \"; Path=\" + options.path;\n    }\n    if (options.expires) {\n        if (!isDate(options.expires) ||\n            !Number.isFinite(options.expires.valueOf())) {\n            throw new TypeError(`option expires is invalid: ${options.expires}`);\n        }\n        str += \"; Expires=\" + options.expires.toUTCString();\n    }\n    if (options.httpOnly) {\n        str += \"; HttpOnly\";\n    }\n    if (options.secure) {\n        str += \"; Secure\";\n    }\n    if (options.partitioned) {\n        str += \"; Partitioned\";\n    }\n    if (options.priority) {\n        const priority = typeof options.priority === \"string\"\n            ? options.priority.toLowerCase()\n            : undefined;\n        switch (priority) {\n            case \"low\":\n                str += \"; Priority=Low\";\n                break;\n            case \"medium\":\n                str += \"; Priority=Medium\";\n                break;\n            case \"high\":\n                str += \"; Priority=High\";\n                break;\n            default:\n                throw new TypeError(`option priority is invalid: ${options.priority}`);\n        }\n    }\n    if (options.sameSite) {\n        const sameSite = typeof options.sameSite === \"string\"\n            ? options.sameSite.toLowerCase()\n            : options.sameSite;\n        switch (sameSite) {\n            case true:\n            case \"strict\":\n                str += \"; SameSite=Strict\";\n                break;\n            case \"lax\":\n                str += \"; SameSite=Lax\";\n                break;\n            case \"none\":\n                str += \"; SameSite=None\";\n                break;\n            default:\n                throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);\n        }\n    }\n    return str;\n}\n/**\n * URL-decode string value. Optimized to skip native call when no %.\n */\nfunction decode(str) {\n    if (str.indexOf(\"%\") === -1)\n        return str;\n    try {\n        return decodeURIComponent(str);\n    }\n    catch (e) {\n        return str;\n    }\n}\n/**\n * Determine if value is a Date.\n */\nfunction isDate(val) {\n    return __toString.call(val) === \"[object Date]\";\n}\n//# sourceMappingURL=index.js.map"],"names":["_ref","cluesData","completedClues","tilesRef","useRef","map","createRef","archiveTiles","filter","clue","date1Str","release","date1","Date","date2","d1","getFullYear","getMonth","getDate","d2","getTime","index","getRelease","completedClue","find","c","id","stats","React","className","hints","guesses","Link","to","concat","how","key","toLocaleString","month","ref","current","src","difficulty","Number","getImg","title","value","cookieNameRegExp","cookieValueRegExp","domainValueRegExp","pathValueRegExp","__toString","Object","prototype","toString","NullObject","C","create","startIndex","str","max","code","charCodeAt","endIndex","min","decode","indexOf","decodeURIComponent","e"],"sourceRoot":""}